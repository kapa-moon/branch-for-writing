import { TiptapDocument } from '@/types/tiptap';
import { IdentityDiffResult, ThemeComparison } from './diffEngine';

/**
 * AI-Powered Identity Diff Engine
 * 
 * This replaces the hard-coded comparison logic with AI-generated analysis.
 * All comparison cards are now generated by AI from the start, providing
 * more nuanced and contextual identity theme analysis.
 * 
 * Now includes database caching to save API calls between sessions.
 */
export class AIIdentityDiffEngine {
  constructor() {
    // Remove in-memory cache as we now use database persistence
  }

  /**
   * Generate AI-powered identity diff analysis with database caching
   * This replaces the old hard-coded generateIdentityDiff method
   */
  public async generateIdentityDiff(
    mainNarrative: TiptapDocument, 
    comparisonNarrative: TiptapDocument,
    mainDocId?: string,
    refDocId?: string
  ): Promise<IdentityDiffResult> {
    
    try {
      console.log('ðŸ¤– Generating AI-powered comparison analysis...', { mainDocId, refDocId });
      
      // Call our new AI comparison API with document IDs for caching
      const response = await fetch('/api/ai/generate-comparisons', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          mainContent: mainNarrative,
          comparisonContent: comparisonNarrative,
          mainDocId, // Pass for database caching
          refDocId   // Pass for database caching
        }),
      });

      if (!response.ok) {
        let errorData = null;
        try {
          errorData = await response.json();
        } catch (parseError) {
          console.warn('Failed to parse error response as JSON:', parseError);
        }
        
        console.error('AI comparison generation failed:', {
          status: response.status,
          statusText: response.statusText,
          url: response.url,
          errorData,
          mainDocId,
          refDocId
        });
        
        // Provide more specific error handling
        if (response.status === 401) {
          console.error('Authentication failed - user session may have expired');
        } else if (response.status === 500) {
          console.error('Server error - check OpenAI API key configuration or database connection');
        }
        
        // Fallback to minimal hard-coded analysis if AI fails
        return this.generateFallbackComparison(mainNarrative, comparisonNarrative);
      }

      const result = await response.json();
      
      if (result.cached) {
        console.log('âœ… Used cached AI comparison results from database');
      } else {
        console.log('âœ… AI comparison analysis completed and cached to database');
      }
      
      // Remove the cached flag from the result before returning
      const { cached, cachedAt, ...cleanResult } = result;
      return cleanResult;
      
    } catch (error) {
      console.error('Error in AI comparison generation:', error);
      
      // Fallback to basic comparison if AI completely fails
      return this.generateFallbackComparison(mainNarrative, comparisonNarrative);
    }
  }

  /**
   * Clear cache for a specific comparison
   * This allows users to force regeneration of AI analysis
   */
  public async clearComparisonCache(mainDocId: string, refDocId: string): Promise<void> {
    try {
      console.log('ðŸ—‘ï¸ Clearing cache for comparison:', { mainDocId, refDocId });
      
      const response = await fetch('/api/ai/clear-comparison-cache', {
        method: 'DELETE',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          mainDocId,
          refDocId
        }),
      });

      if (response.ok) {
        console.log('âœ… Cache cleared successfully');
      } else {
        console.warn('Failed to clear cache, but continuing...');
      }
    } catch (error) {
      console.warn('Error clearing cache (non-blocking):', error);
    }
  }

  /**
   * Legacy method for backward compatibility
   * @deprecated Use clearComparisonCache instead
   */
  public clearCache(): void {
    console.log('âš ï¸ Legacy clearCache called - use clearComparisonCache for database cache clearing');
  }

  /**
   * Minimal fallback comparison if AI fails
   * This retains some hard-coded logic only as a backup
   */
  private generateFallbackComparison(
    mainNarrative: TiptapDocument,
    comparisonNarrative: TiptapDocument
  ): IdentityDiffResult {
    console.log('âš ï¸ Using fallback comparison analysis');
    
    const mainText = this.documentToText(mainNarrative);
    const comparisonText = this.documentToText(comparisonNarrative);
    
    // Very basic analysis as fallback
    const wordCountDiff = comparisonText.split(' ').length - mainText.split(' ').length;
    
    return {
      holistic: [{
        type: 'holistic',
        category: 'structural',
        description: `Content ${wordCountDiff > 0 ? 'expanded' : 'condensed'} by ${Math.abs(wordCountDiff)} words`,
        significance: Math.min(Math.abs(wordCountDiff) / 100, 1),
        explanation: 'Basic structural change detected. Full AI analysis unavailable.'
      }],
      overlapping: [],
      unique: {
        mainNarrative: [],
        comparisonNarrative: []
      },
      conflicts: [],
      summary: {
        majorDifferences: ['AI analysis temporarily unavailable'],
        identityShifts: ['Please check your internet connection and API configuration'],
        recommendations: ['Try refreshing to re-attempt AI analysis']
      }
    };
  }

  /**
   * Convert TiptapDocument to text for processing
   */
  private documentToText(doc: TiptapDocument): string {
    const extractFromNodes = (nodes: any[]): string => {
      return nodes.map(node => {
        if (node.type === 'text') {
          return node.text || '';
        } else if (node.content) {
          return extractFromNodes(node.content);
        }
        return '';
      }).join(' ');
    };

    return extractFromNodes(doc.content || []);
  }
} 